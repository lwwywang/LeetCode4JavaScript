给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。

子数组 定义为原数组中的一个连续子序列。

请你返回 arr 中 所有奇数长度子数组的和 。

 

示例 1：

输入：arr = [1,4,2,5,3]
输出：58
解释：所有奇数长度子数组和它们的和为：
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
示例 2：

输入：arr = [1,2]
输出：3
解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。
示例 3：

输入：arr = [10,11,12]
输出：66
 

提示：

1 <= arr.length <= 100
1 <= arr[i] <= 1000
 

进阶：

你可以设计一个 O(n) 时间复杂度的算法解决此问题吗？

---------

## 题解

## 解题思路

这段代码定义了一个函数 sumOddLengthSubarrays，其目的是计算一个数组中所有奇数长度子数组的元素和。

1. 首先，检查输入数组 arr 是否为空，如果是，则直接返回 0。
2. 初始化变量 result 用于存储最终结果，即所有奇数长度子数组的和。
3. 创建一个名为 prefixSum 的数组，用于存储输入数组 arr 的前缀和。前缀和是一个数组，其中每个元素 prefixSum[i] 表示原数组 arr 中从第一个元素到第 i 个元素的总和。这里 prefixSum 的长度比 arr 多 1，且初始填充为 0，这是为了方便计算。
4. 使用一个循环计算 prefixSum，通过累加当前元素和前一个元素的前缀和来实现。
5. 接下来，使用两个嵌套循环来遍历数组 arr，外层循环变量 i 表示子数组的起始位置，内层循环变量 length 表示子数组的长度。注意，内层循环的步长为 2，这确保了只考虑奇数长度的子数组。
6. 在内层循环中，通过前缀和数组 prefixSum 计算从第 i 个元素开始长度为 length 的子数组的和，然后将这个和加到 result 上。

--
前缀和数组prefixSum的功能是存储原数组arr从第一个元素开始到当前元素的累积和。具体来说，prefixSum[i]表示arr数组中从第0个元素到第i-1个元素的总和。这种方法通过预计算和存储中间结果来优化性能，使得计算任意子数组的和变得更加高效。在这段代码中，prefixSum数组被用于计算所有奇数长度子数组的和。通过使用前缀和数组，我们可以在O(1)的时间复杂度内计算出任意子数组的和，即prefixSum[i+length] - prefixSum[i]给出了从第i个元素开始长度为length的子数组的和。这样，整个算法的时间复杂度主要由外层和内层循环决定，而不是子数组求和操作。
--
计算 prefixSum[i+1] 的原因是为了构建一个前缀和数组，这样做的目的是为了快速计算任意子数组的和。在这个上下文中，prefixSum[i] 表示数组 arr 从索引 0 到索引 i-1（包含）的所有元素的和。因此，prefixSum[i+1] 实际上表示从索引 0 到索引 i（包含）的所有元素的和。

这种方法的优势在于，一旦前缀和数组被计算出来，我们就可以在 O(1) 的时间复杂度内计算出任意子数组的和。例如，子数组 arr[l...r] 的和可以通过 prefixSum[r+1] - prefixSum[l] 快速得到，其中 l 和 r 分别是子数组的起始和结束索引。