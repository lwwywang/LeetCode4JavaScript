给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target  的那两个整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]
 

提示：

2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
只会存在一个有效答案
 

进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？

----------

## 题解

其时间复杂度为 O(n)，远低于题目进阶要求的 O(n^2)。下面是解题思路的详细解释：

**创建一个空对象 map**：这个对象用于存储遍历过程中各个元素的值和它们对应的索引。键是元素的值，值是元素的索引。

**遍历数组 nums**：通过一个 for 循环遍历给定数组 nums 的每个元素。

**计算补数 complement**：对于当前元素 nums[i]，计算目标值 target 与 nums[i] 的差值，这个差值称为“补数”（complement）。补数是我们需要在数组的其余部分中查找的数，以使得 nums[i] + complement = target。

**检查 map 中是否存在 complement**：检查之前存储在 map 对象中的键是否包含当前的补数 complement。如果存在，这意味着我们找到了两个数，它们的和等于 target。因为 map[complement] 存储的是补数的索引，所以我们可以直接使用 [map[complement], i] 作为返回值，其中 i 是当前数字的索引。

**将当前元素和其索引存入 map**：如果当前的补数不在 map 中，就将当前元素的值和索引作为键值对存入 map。这样，当遍历到后面的元素时，我们可以快速检查其补数是否已经在数组的前面部分出现过。

返回结果：一旦找到满足条件的两个数，函数就会返回这两个数的索引组成的数组。根据题目要求，这样的一对数是唯一的。