给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的
子集
（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

 

示例 1：

输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
示例 2：

输入：nums = [0]
输出：[[],[0]]
 

提示：

1 <= nums.length <= 10
-10 <= nums[i] <= 10
nums 中的所有元素 互不相同


----

思路：
函数定义： 定义了一个名为 subsets 的函数，接收一个数组 nums 作为参数。

初始化解集： 创建一个空数组 res，用于存储所有子集。

输入校验： 检查输入数组是否为 null 或者长度为 0，如果是，则返回 null。

初始化单一解： 创建一个空数组 list，用于存储当前子集。

数组排序： 将输入数组进行排序，确保子集按顺序生成。

调用辅助函数计算子集： 调用辅助函数 helper，传入 res、list、nums 和起始位置 0。

返回结果： 返回包含所有子集的数组 res。

**辅助函数 helper**： 该函数通过递归方式生成所有子集。

将当前子集 list 的副本加入结果集 res。
遍历从当前位置 position 到数组末尾的所有元素：
将当前元素加入子集 list。
递归调用 helper 生成以当前元素为起点的子集。
回溯，移除当前元素。
示例测试： 通过两个示例测试验证函数的正确性：

subsets([1, 2, 3]) 输出所有可能的子集。
subsets([0]) 输出 [[], [0]]。
总结：该代码通过递归和回溯的方法生成所有可能的子集，并将其存储在结果数组 res 中。

----
第二次思考，为什么要position

递归起始点控制：

position参数确保每次递归调用只考虑从当前position开始及其之后的元素。这避免了重复选择相同的元素。
比如，当position为0时，表示从数组的第一个元素开始考虑；当position为1时，表示从第二个元素开始考虑，以此类推。
避免重复子集：

在生成子集时，如果没有position，递归可能会重新考虑已经处理过的元素，导致生成重复的子集。通过从position开始的循环，确保每个元素只被添加到子集一次。


helper(res, list, nums, i + 1);使用i + 1而不是position + 1是因为i代表当前正在处理的元素在数组中的索引，而position只是递归调用的起始点。