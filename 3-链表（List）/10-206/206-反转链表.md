给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
 

示例 1：


输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
示例 2：


输入：head = [1,2]
输出：[2,1]
示例 3：

输入：head = []
输出：[]
 

提示：

链表中节点的数目范围是 [0, 5000]
-5000 <= Node.val <= 5000
 

进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

-----------

思路：
参数检查：首先，函数检查传入的 head（链表的头节点）是否为 null。如果是，表示链表为空，直接返回 null。

初始化：接着，函数初始化一个名为 prev 的变量，用于存储当前节点的前一个节点。初始时，prev 被设置为 null，因为反转后的链表的第一个节点（原链表的最后一个节点）的 next 应该指向 null。

遍历链表：函数使用一个 while 循环遍历整个链表。循环的条件是 head 不等于 null，即直到遍历完整个链表。

反转操作：在每次循环中，函数执行以下操作来实现反转：

使用一个临时变量 temp 存储当前节点 head 的下一个节点，以便head 指针之后的内容不会丢失。

将当前节点 head 的 next 指针指向 prev，实现反转。
更新 prev 为当前的 head 节点，为下一次迭代准备。
将 head 更新为 temp，即移动到原链表的下一个节点。
    head.next = prev;：将当前节点的下一个节点指向前一个节点。在反转链表的过程中，这是实现反转的关键步骤，因为链表的方向被改变了。

    prev = head;：将前一个节点移动到当前节点。这一步是为了在下一次迭代中，能够将下一个节点的 next 指向这个新的 prev 节点，即当前的 head 节点。

    head = temp;：将当前节点移动到下一个节点。在这之前，temp 应该已经被设置为 head.next（这部分代码在选中的代码之前），这样可以继续遍历链表直到结束。


返回反转后的链表头：当 while 循环结束时，head 会变为 null，表示已经遍历完整个链表。此时，prev 指向的是反转后链表的头节点。因此，函数最后返回 prev。

