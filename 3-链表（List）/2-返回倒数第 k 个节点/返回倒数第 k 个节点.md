实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

注意：本题相对原题稍作改动

示例：

输入： 1->2->3->4->5 和 k = 2
输出： 4
说明：

给定的 k 保证是有效的。

----------

思路：
1. 定义 kthToLast 函数：这个函数接受两个参数，head（链表的头节点）和 k（要找的倒数第 k 个节点）。

2. 边界条件检查：如果输入的头节点 head 为 null，即链表为空，则直接返回 null。

3. 初始化快慢指针：定义两个指针 fast 和 slow，都初始化为头节点 head。这两个指针将用于遍历链表。

4. 移动快指针：先将快指针 fast 向前移动 k-1 次（因为我们要找的是倒数第 k 个节点，所以快指针需要先走 k-1 步，以确保快慢指针之间有 k-1 个节点的距离）。这样，当快指针到达链表末尾时，慢指针将指向倒数第 k 个节点。

5. 同时移动快慢指针：当快指针 fast 和它的下一个节点 fast.next 都不为 null 时，同时移动快慢指针，直到快指针到达链表的末尾。这时，慢指针 slow 将指向倒数第 k 个节点。

6. 返回结果：返回慢指针 slow 指向的节点。由于题目要求返回节点的值，因此最后输出 kthToLast(head, 2).val，这里 .val 是为了获取节点的值。



----------

假设我们有一个链表和一个任务：找到倒数第 k=3 个节点。链表如下：

我们想要找到倒数第 3 个节点，即节点 3。按照算法，我们这样操作：

初始化：快指针 fast 和慢指针 slow 都指向头节点，即节点 1。

移动快指针：因为我们要找的是倒数第 3 个节点，我们先将快指针 fast 向前移动 k-1=2 次。移动后的情况如下：

此时，快指针 fast 指向节点 3，慢指针 slow 仍然指向头节点 1。

同时移动快慢指针：接下来，我们同时移动快慢指针，直到快指针 fast 到达链表的末尾。每次移动，快慢指针都向前进一步，直到 fast 指向 null（链表末尾）。

----------

错题本记录

*** 在这个算法中，fast 先走的目的是为了在链表中创建一个固定的间隔，这个间隔等于 k。这样做的原因是，当 fast 指针到达链表的末尾时，slow 指针将会指向倒数第 k 个节点。这是一种常见的双指针技巧，用于解决链表中的问题，特别是当需要访问链表的倒数第 k 个元素时。 ***


1. 在第一个 while 循环中，你没有正确地递减 index，导致循环不会按预期次数执行。
2. 第二个 while 循环的条件应该是 fast.next !== null，而不是 fast !== null && fast.next !== null，因为在第一个循环中，fast 已经移动了 k-1 次。

