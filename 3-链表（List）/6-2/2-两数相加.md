给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

示例 1：


输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
示例 2：

输入：l1 = [0], l2 = [0]
输出：[0]
示例 3：

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
 

提示：

每个链表中的节点数在范围 [1, 100] 内
0 <= Node.val <= 9
题目数据保证列表表示的数字不含前导零

-----------

## 思路

创建一个哑节点（dummyNode）和一个指针（head），指针初始时指向哑节点。哑节点用于简化在头节点前插入节点的操作，最后返回的结果将从哑节点的下一个节点开始。

初始化一个变量 carry 用于存储进位，初始值为0。

使用一个循环同时遍历两个链表（l1 和 l2），直到两个链表都遍历完毕。在每次循环中：

分别获取两个链表当前节点的值（num1 和 num2），计算它们的和加上前一位的进位（carry）。
计算当前位的值（value）为和的个位数，进位（carry）为和除以10的商。
创建一个新节点，值为当前位的值（value），并将其添加到结果链表的末尾。
移动指针，继续遍历两个链表的下一个节点。
如果两个链表长度不同，继续遍历较长的链表，将剩余部分加上进位继续添加到结果链表中。
遍历完两个链表后，如果还有进位（carry不为0），则在结果链表的末尾添加一个节点，节点的值为进位的值。

返回哑节点的下一个节点，即结果链表的头节点。

-----------

错题记录：
因为会存在carry不为0，即，相加后carry还有值，所以要添加一个carry不等于0自动添加进位的节点。

移动的时候除了l1/l2要移动，head也要移动