将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

示例 1：


输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
示例 2：

输入：l1 = [], l2 = []
输出：[]
示例 3：

输入：l1 = [], l2 = [0]
输出：[0]
 

提示：

两个链表的节点数目范围是 [0, 50]
-100 <= Node.val <= 100
l1 和 l2 均按 非递减顺序 排列

-----------

思路：

这段代码定义了一个函数mergeTwoLists，其目的是将两个已排序的链表list1和list2合并成一个新的、同样有序的链表，并返回合并后的链表的头节点。这里是它的工作原理：

检查空链表：首先，如果list1和list2都是null，即两个链表都为空，那么直接返回null，因为没有什么可以合并的。

创建哑节点：接着，创建一个哑节点dummyNode，其值为-1（这个值通常是任意的，因为它不会被包含在最终的合并链表中）。dummyNode的目的是提供一个无关紧要的起始点，它的next指针将指向合并后链表的头节点。这样做可以简化边界条件的处理，使代码更加简洁。head变量用于跟踪新链表的最后一个节点。

遍历两个链表：然后，使用一个while循环同时遍历list1和list2，直到其中一个链表被完全遍历。在每次迭代中，比较当前list1和list2节点的值。将值较小的节点接到head的后面，并将head和选中的链表（list1或list2）向前移动一步。

处理剩余元素：退出循环后，至少有一个链表已经被完全遍历。如果list1或list2中有一个不是null（即还有剩余的节点未被合并），则将其余部分直接接到head的后面。这是安全的，因为这个剩余部分已经是有序的，并且所有值都大于合并链表中当前的最后一个值。

返回合并后的链表：最后，返回dummyNode.next。由于dummyNode是一个哑节点，其next属性指向合并后链表的头节点。

-----------

错题本记录

1. 代码中存在一个错误，在合并两个链表时，对list1的处理不正确。具体来说，当list1.val < list2.val时，应该将list1向前移动一步，但是代码中错误地将list1.next设置为list1自身，这会导致无限循环。正确的做法是将list1更新为list1.next。


2. 在返回当一个列表值为空的情况时，应该定义谁不为空，就把head.next指向谁

