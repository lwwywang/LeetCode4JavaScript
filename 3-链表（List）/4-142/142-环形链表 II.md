给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。

 

示例 1：



输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
示例 2：



输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
示例 3：



输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
 

提示：

链表中节点的数目范围在范围 [0, 104] 内
-105 <= Node.val <= 105
pos 的值为 -1 或者链表中的一个有效索引
 

进阶：你是否可以使用 O(1) 空间解决此题？\



-------

思路：
初始化检查：首先检查链表是否为空或者只有一个节点，如果是，则直接返回false，因为在这种情况下不可能形成环。

定义快慢指针：定义两个指针fast和slow，它们都从链表的头节点head开始。

移动快慢指针：在一个while循环中，fast指针每次移动两步，slow指针每次移动一步。这个循环的条件是fast不为null且fast.next也不为null，以确保fast指针可以安全地前进两步。

检测环：如果在某一时刻fast和slow相遇（即指向同一个节点），这意味着链表中存在环。

找到环的入口：

当fast和slow相遇时，定义一个新的指针current从头节点head开始。
然后，current和slow同时每次移动一步，直到它们相遇。
它们相遇的节点就是环的入口。
返回结果：如果链表中存在环，则返回环的入口节点。如果循环结束也没有找到环（即fast遇到了null），则返回false。

--------

错题本记录：
我们可以利用以下数学性质：

假设链表头到环入口的距离是D，环入口到快慢指针相遇点的距离是S，环的长度是C。
当快慢指针相遇时，假设慢指针走了D+S的距离，那么快指针则走了D+S+nC的距离，其中n是快指针在环内走的圈数。
因为快指针的速度是慢指针的两倍，所以快指针走的距离是慢指针的两倍，即2(D+S) = D+S+nC。
通过简化上述等式，我们可以得到D = nC - S。这意味着从链表头到环入口的距离等于n圈环长度减去从环入口到相遇点的距离。
基于上述性质，我们可以找到环的入口：

当fast和slow指针在环中相遇后，我们定义一个新的指针current，它从链表的头节点head开始。
然后，current和slow指针同时每次移动一步。
由于D = nC - S，当current和slow同时出发，它们最终会在环的入口相遇，因为它们离环入口的距离相同。
它们相遇的节点就是环的入口。


----

检测环的存在：

    使用两个指针 fast 和 slow，其中 fast 每次移动两步，slow 每次移动一步。
    如果链表中存在环，fast 和 slow 最终会在环中相遇。

找到环的起始位置：

    当 fast 和 slow 相遇时，说明链表中存在环。
    此时，将一个新的指针 current 指向链表的头部 head，并保持 slow 在相遇点。
    然后同时移动 current 和 slow，每次都移动一步。
    当 current 和 slow 再次相遇时，相遇点就是环的起始位置。