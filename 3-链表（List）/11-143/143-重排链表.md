给定一个单链表 L 的头节点 head ，单链表 L 表示为：

L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 

示例 1：



输入：head = [1,2,3,4]
输出：[1,4,2,3]
示例 2：



输入：head = [1,2,3,4,5]
输出：[1,5,2,4,3]
 

提示：

链表的长度范围为 [1, 5 * 104]
1 <= node.val <= 1000

-------------

思路：

这道题的要求是将链表重新排列，但是不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
实际上是，先求中点（用快慢指针）。
然后用反转列表，得到中点之后的链表反转。
然后将两个链表合并成一个链表。
最后再将合并后的链表再反转，得到最终的结果。


-------------

错题记录：
代码超时的原因在于reorderList函数中的逻辑处理。具体来说，问题出现在mergeList函数中。在mergeList函数中，你正确地交替地从两个链表中取节点进行合并。但是，问题出现在middleList函数将原链表一分为二后，没有将前半部分的链表与后半部分（即将被反转的部分）断开。这意味着当你开始合并链表时，原链表的中点的next指针仍然指向后半部分的头节点，这导致了一个循环链表的出现，从而在尝试打印或遍历合并后的链表时造成了无限循环，进而导致超时。