单调栈是一种特殊的栈结构，主要用于解决一类特定的问题，这类问题通常涉及到需要快速找到一个序列中某个元素左边或右边第一个比它大（或小）的元素。单调栈按照元素的单调性（递增或递减）来维护栈内元素，以此来实现快速查询。

单调栈的特点如下：

单调递增栈：在这种栈中，从栈底到栈顶的元素是单调递增的。当新的元素比栈顶元素大时，直接将新元素入栈；如果新元素比栈顶元素小，则栈顶元素出栈，直到栈顶元素小于新元素，然后将新元素入栈。这种栈可以用来找到元素左边第一个比它小的元素。

单调递减栈：在这种栈中，从栈底到栈顶的元素是单调递减的。当新的元素比栈顶元素小时，直接将新元素入栈；如果新元素比栈顶元素大，则栈顶元素出栈，直到栈顶元素大于新元素，然后将新元素入栈。这种栈可以用来找到元素左边第一个比它大的元素。

单调栈的应用场景非常广泛，比如在数组中寻找每个元素的下一个更大元素、计算直方图中最大矩形面积等问题。通过单调栈，这些问题可以在较低的时间复杂度内得到解决，通常是线性时间复杂度O(n)。


---------

思路：
先初始化数组，在初始化数组之后，

对于找【右侧更大的】
如果栈不为空且当前元素大于栈顶元素，则栈顶元素的右侧第一个更大的元素就是当前元素，将当前元素入栈。
//while(!stack.isEmpyt() && stack.peek() < nums[i]) 栈顶元素小于当前元素
更新结果并弹出栈顶元素：如果找到了这样的元素，const index = this.stack.pop();会从栈中移除栈顶元素的索引，并将其存储在index变量中。然后，result[index] = nums[i];会将nums[i]（即右边第一个比栈顶元素大的值）存储在结果数组的相应位置上。

将当前元素索引入栈：this.stack.push(i);这一步骤将当前元素的索引i添加到栈中。这是为了后续的元素继续寻找它们右边第一个比它们大的元素。

-------
简略记法：
更大的，比较值就为小于号；更小的，比较值就为大于号。
找右边的，i=0, i<length, i++
找左边的，i=length-1, i>=0, i--

-------
错题本：

1. for 循环条件中的 nums.length[i] 应该是 nums.length。
2. this.stack.push() 缺少参数，应该是 this.stack.push(i)。
