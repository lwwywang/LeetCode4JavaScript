给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。


示例 1:

输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
示例 2:

输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
 

提示：

你可以假设 nums 中的所有元素是不重复的。
n 将在 [1, 10000]之间。
nums 的每个元素都将在 [-9999, 9999]之间。

------------

## 解题思路

这段代码是二分查找算法的一部分，用于在有序数组nums中查找目标值target。代码的逻辑如下：

如果目标值小于中间值 (if (target < nums[mid]))：这意味着目标值位于当前中点mid的左侧，因此需要将搜索范围的结束点end更新为mid，以便在左半部分继续搜索。

如果目标值大于中间值 (else if (target > nums[mid]))：这表明目标值位于当前中点mid的右侧，因此需要将搜索范围的起始点start更新为mid，以便在右半部分继续搜索。

否则 (else)：这个分支处理的是target == nums[mid]的情况，即目标值等于中间值。但在这个特定的代码片段中，而不是直接返回找到的索引mid或结束搜索，它将end更新为mid。这种处理方式不是标准的二分查找行为，因为在找到目标值时，通常会直接返回索引或进行其他操作，而不是继续调整搜索范围。

这段代码的特殊之处在于，无论目标值是小于还是等于中间值，end都被设置为mid。这可能是为了处理某种特定的查找逻辑或是代码的错误。通常，在二分查找中，如果找到目标值，会有一个明确的返回语句或其他操作，而不是像这里那样仅仅调整搜索范围。此外，这段代码可能会导致无限循环，因为如果target等于nums[mid]，仅仅将end设置为mid而不改变mid的计算方式或不终止循环，可能会导致算法在某些情况下无法进展。正确的做法是在找到目标值时返回其索引，或者在更新start或end时采用start = mid + 1或end = mid - 1，以确保搜索范围能够有效缩小。

------------
错题本记录：
是因为数组索引是从0开始的。例如，一个有5个元素的数组，其索引范围是0到4，所以数组的最后一个元素的索引是数组长度 - 1