编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

示例 1：
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
示例 2：
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
 

提示：

m == matrix.length
n == matrix[i].length
1 <= n, m <= 300
-109 <= matrix[i][j] <= 109
每行的所有元素从左到右升序排列
每列的所有元素从上到下升序排列
-109 <= target <= 109


------------

## 解题思路
定义了一个函数 searchMatrix，用于在一个二维矩阵中搜索一个指定的目标值 target。如果找到目标值，则返回 true；否则，返回 false。这个算法特别适用于每行的元素从左到右递增，每列的元素从上到下递增的矩阵。以下是代码的详细解释：

参数检查：首先，函数检查输入的矩阵 matrix 是否为空或者不合法（例如，矩阵的第一行为空或者矩阵的长度为0）。如果是，则直接返回 false。

初始化变量：

    m：矩阵的列数减一（因为索引从0开始）。
    n：矩阵的行数减一。
    x 和 y：分别初始化为矩阵的左下角的坐标（0 和 m-1），即右上角的元素。

搜索逻辑：使用 while 循环来遍历矩阵：

    如果当前元素 matrix[x][y] 等于目标值 target，则找到目标值，返回 true。
    如果当前元素 matrix[x][y] 大于目标值 target，则目标值不可能在当前元素的右边（因为右边的元素都更大），因此 y-- 向左移动。
    如果当前元素 matrix[x][y] 小于目标值 target，则目标值不可能在当前元素的上方（因为上方的元素都更小），因此 x++ 向下移动。

循环条件：while(x < n && y >= 0) 确保搜索过程在矩阵的有效范围内进行。当 x 或 y 超出矩阵的边界时，循环结束。

返回值：如果循环结束还没有找到目标值，则返回 false。
