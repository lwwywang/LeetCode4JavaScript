编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

示例 1：
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
示例 2：
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
 

提示：

m == matrix.length
n == matrix[i].length
1 <= n, m <= 300
-109 <= matrix[i][j] <= 109
每行的所有元素从左到右升序排列
每列的所有元素从上到下升序排列
-109 <= target <= 109


------------

## 解题思路
定义了一个函数 searchMatrix，用于在一个二维矩阵中搜索一个指定的目标值 target。如果找到目标值，则返回 true；否则，返回 false。这个算法特别适用于每行的元素从左到右递增，每列的元素从上到下递增的矩阵。以下是代码的详细解释：

参数检查：首先，函数检查输入的矩阵 matrix 是否为空或者不合法（例如，矩阵的第一行为空或者矩阵的长度为0）。如果是，则直接返回 false。

初始化变量：

    m：矩阵的列数减一（因为索引从0开始）。
    n：矩阵的行数减一。
    x 和 y：分别初始化为矩阵的左下角的坐标（0 和 m-1），即右上角的元素。

搜索逻辑：使用 while 循环来遍历矩阵：

    如果当前元素 matrix[x][y] 等于目标值 target，则找到目标值，返回 true。
    如果当前元素 matrix[x][y] 大于目标值 target，则目标值不可能在当前元素的右边（因为右边的元素都更大），因此 y-- 向左移动。
    如果当前元素 matrix[x][y] 小于目标值 target，则目标值不可能在当前元素的上方（因为上方的元素都更小），因此 x++ 向下移动。

循环条件：while(x < n && y >= 0) 确保搜索过程在矩阵的有效范围内进行。当 x 或 y 超出矩阵的边界时，循环结束。

返回值：如果循环结束还没有找到目标值，则返回 false。


=========

74代码使用的是一种基于二分查找的算法。具体步骤如下：

检查矩阵是否为空或无效。
将矩阵视为一个一维数组进行二分查找。
通过计算中间位置的索引来确定对应的二维矩阵中的元素。
根据目标值与中间元素的比较结果调整查找范围。
最后检查起始和结束位置的元素是否为目标值。


240代码使用的是一种从矩阵右上角开始的搜索算法。具体步骤如下：

检查矩阵是否为空或无效。
从矩阵的右上角开始搜索。
根据目标值与当前元素的比较结果决定移动方向：如果目标值小于当前元素，向左移动；如果目标值大于当前元素，向下移动。
如果找到目标值则返回 true，否则继续搜索直到超出矩阵边界。

区别
算法不同：
第一段代码使用二分查找，时间复杂度为 O(log(m*n))。
第二段代码使用从右上角开始的搜索，时间复杂度为 O(m + n)。
实现细节不同：
第一段代码将矩阵视为一维数组进行处理。
第二段代码直接在二维矩阵上进行操作。


错误更正：
逻辑有一个错误：你从右上角开始搜索时，y 应该是列的索引，而不是行的索引。因此，y 应该初始化为 m - 1 而不是 n - 1。此外，x 应该是行的索引，初始化为 0 是正确的。