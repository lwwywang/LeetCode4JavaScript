给你一个满足下述两条属性的 m x n 整数矩阵：

每行中的整数从左到右按非严格递增顺序排列。
每行的第一个整数大于前一行的最后一个整数。
给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。

示例 1：


输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
示例 2：


输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
 

提示：

m == matrix.length
n == matrix[i].length
1 <= m, n <= 100
-104 <= matrix[i][j], target <= 104


-----------

思路：
1. 首先对矩阵进行一下判断，判断是否为空，如果为空直接返回false
2. 接下来定义一下row和column，为把矩阵拍平成一维数组做准备
3. 然后上二分搜索的老套路，定义start和end
4. start就是数组起始点0；由于二维数组已经被拍平，end就是row*column - 1
5. 定义x/y来表示将拍平的一维数组还原回二维应该怎么表示
6. x用来表示行，通过计算可得，当前的index除以列之后再取整就是对应的行数
7. y用来表示列，通过计算可得，当前的index对列去余数就是对应的列数
8. 接下来进行判断：
   1. 当target=目标数时，直接return true
   2. 当target大于目标数时，说明mid的结尾都比target小，所以让start=mid
   3. 当target小于目标数时，说明应该缩小范围，让end=mid
9. 判断为true的条件是，start or end 有一个值等于target即可



-----------

错题本记录：

1. 数组的判断不光判断数组本身是不是为空，数组长度是不是为空，还要判断第一个是不是为空，比如[[],[],[]]，其实是一个空数组，第一个元素为空，但length为3，matrix也不是null。
2. 先定义数组的行和列，尽管会把这个二维数组抽象成一维数组。
3. start和end因为是可变的，所以不能用const只能用let。
4. mid一定要用Math.floor()取整，否则会出现小数。
5. 同理x/y也是一样。x/y也是抽象成一维数组的变量。
6. 判断用==
7. 最后的if判断要写在最外面。

几个疑问，还是关于二分搜索，最后判断的条件到底应该是什么原理？
=> 如果start等于target，那就返回start；如果end等于target，那就返回end。

while中间if/else比大小的逻辑到底应该是什么？
=> 如果target大于现在的mid，那么说明start取小了，应该让start=mid；如果target小于现在的mid，那么说明end取大了，应该让end=mid。

为什么通过mid就能够和martix[x][y]进行比较？
=> 因为mid是通过二分搜索得到的，所以mid一定是某个元素的下标，通过这个下标就可以找到对应的元素。