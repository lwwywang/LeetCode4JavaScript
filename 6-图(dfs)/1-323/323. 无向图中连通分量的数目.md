你有一个包含 n 个节点的图。给定一个整数 n 和一个数组 edges ，其中 edges[i] = [ai, bi] 表示图中 ai 和 bi 之间有一条边。

返回 图中已连接分量的数目 。

 

示例 1:



输入: n = 5, edges = [[0, 1], [1, 2], [3, 4]]
输出: 2
示例 2:



输入: n = 5, edges = [[0,1], [1,2], [2,3], [3,4]]
输出:  1
 

提示：

1 <= n <= 2000
1 <= edges.length <= 5000
edges[i].length == 2
0 <= ai <= bi < n
ai != bi
edges 中不会出现重复的边


---

这种方式构建图是为了创建一个邻接表来表示无向图。具体步骤如下：

let graph = new Array(n).fill(0).map(() => new Array())：

创建一个长度为 n 的数组 graph，其中每个元素初始化为一个空数组。
这一步的目的是为图中的每个节点分配一个数组，用于存储与该节点相连的其他节点。
for(let [x, y] of edges){ graph[x].push(y); graph[y].push(x); }：

遍历所有的边 edges，每条边由两个节点 x 和 y 组成。
对于每条边，将节点 y 添加到节点 x 的邻接列表中，同时将节点 x 添加到节点 y 的邻接列表中。
由于是无向图，所以需要在两个方向上都添加连接。

---

let visited = {}; 这行代码是在定义一个对象，用于跟踪图中哪些节点已经被访问过。使用对象而不是数组有以下几个原因：

灵活性：对象可以使用任意类型的键，而数组的键必须是整数。对于图中的节点，特别是当节点编号不是连续的整数时，使用对象更为灵活。

查找效率：对象的键查找时间复杂度为 O(1)，可以快速判断一个节点是否已经被访问过。

内存使用：如果节点编号范围很大但实际节点数较少，使用数组会浪费大量内存，而对象只存储实际访问过的节点。

---

这是 JavaScript 中的 for...of 循环语法，用于遍历可迭代对象（如数组、字符串、Map、Set 等）。在这个例子中，graph[i] 是一个数组，for...of 循环会遍历这个数组的每一个元素，并将当前元素赋值给变量 j。

let j of graph[i] 和 let i = 0; i < n; i++ 是两种不同的循环方式，适用于不同的场景：

let j of graph[i]:

用于遍历数组或对象的元素。
适用于你需要直接访问数组或对象中的每个元素的情况。
例如，当你需要遍历一个图的邻接表时，可以使用这种形式。
let i = 0; i < n; i++:

用于遍历一个范围内的索引。
适用于你需要访问数组或对象的索引，或者需要进行一些基于索引的操作的情况。
例如，当你需要遍历一个数组的所有索引时，可以使用这种形式。
